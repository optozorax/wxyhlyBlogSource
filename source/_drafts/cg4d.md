---
title: 四维图形学技术综述
tags:
  - 四维
  - 图形学
  - 算法
---
用文字再怎样描述四维肯定不及图片、影像甚至游戏来得直接。目前可视化四维的方法到底有哪些呢？之前的文章中几乎都覆盖了：截面法、球极投影、等高面或颜色标注第四维、3D照片等，其中3D照片又分线框与体素云等展示法。这些方法想必多数读者也能理解，但如何利用计算机程序去展示它们却是一个不小的挑战。我们这里先介绍一些最基本的计算机图形学原理，然后深入讲解各种绘制复杂四维物体的方法。读者可以根据自己的知识水平选读。或许我后面可以开一个系列专题，专门讲解怎样一步步自己搭建一个四维图形引擎。
## 计算机图形学基础
这里先非常粗略地介绍一下计算机图形学的基础知识。想要深入了解的话推荐这个在线课程：[《GAMES101-现代计算机图形学入门-闫令琪》](https://www.bilibili.com/video/BV1X7411F744/)。
### 计算机如何显示图形
计算机的显示器本质上就是一堆排列整齐的彩灯在发不同比例强度的光。图形的本质其实就是一个二维像素阵列中储存着这些发光的强度比例的数字。为了快速计算这些动辄上十万、百万数量的像素，人们发明了显卡（GPU），不同于CPU一次执行一条单个的指令，GPU是每次接受一条指令，便同时对所有像素进行相同的运算，这样不同像素同时并行运算就比CPU一次处理一个像素快了成千上万倍。

### 光栅化技术

GPU如何计算显示三维图形呢？现在主流的做法是只绘制点、线、三角形这三种基本图形，其硬件有专门为绘制这几个图形进行优化设计，从而可以运行得非常快。下面就绘制三角形说说大致流程：
1. 首先将组成几何体的三角形的顶点数据发送至GPU
2. 在GPU中对所有顶点数据并行计算坐标变换，得到在画面中的透视投影的最终坐标，这段顶点坐标变换程序叫做“顶点着色器(Vertex Shader)”
3. 通过硬件层面优化过的“光栅化器(Rasterizer)”快速判断图像中哪些像素属于三角形的内部，并且计算其相对于三角形的重心坐标，这部分程序是写死在硬件里的，一般不可编程。
4. 对上一步确定在三角形内部的所有像素进行最终上色，这段程序叫做“片元着色器(Fragment Shader)”。注意这些像素点可以根据重心坐标信息来加以区分从而染上不同的颜色，比如通过映射到各种纹理贴图实现很多材质上的细节效果。

光栅化其实还有一些细节问题是不简单的，比如视锥体裁剪与遮挡剔除。
##### 视锥体裁剪
视锥体是一种表示场景中相机的视野范围的虚拟的四棱锥，位于视野范围外的物体是不会被绘制的，一般来说这些像素点只要落在最终的画布内就行了，然而位于相机正后方的点却不会被剔除，需要单独处理。传统的GPU将投影变换与视锥体裁剪的工作放到了一起，使用一种叫“齐次坐标(Homogeneous Coordinates)”的数学工具。它不仅将非线性的透视变换变成线性的，还顺便轻松处理了视锥体裁剪。我们之前说顶点着色器的输出是投影过后的在画面上的点的坐标其实是不准确的。试想有台相机位于原点，在z=1处放一块投影画布，远处的点$p(x,y,z)$在画布上的像的位置其实是$b(x/z,y/z,1)$。这个除以$z$的操作叫做“透视除法”，因为这个$1/z$的因子导致了“近大远小”这一最重要的透视现象。然而透视除法有个很严重的问题，就是相机背后的点会跑到相机前面来，比如点$p(x,y,z)$与点$p(-x,-y,-z)$它们都会本映射到屏幕上同一点，然而实际上仅有一个点位于相机前方能被看到，因此视锥体裁剪要在透视除法之前完成。要注意的是，视锥体裁剪并不能仅仅在顶点着色器这一阶段完成，它将在光栅化阶段对每个像素进行判断，不然你没办法正确渲染那种一半位于相机前、一半位于相机后的线段或三角形。

既然不能提前去除以这个因子$z$，人们就规定，顶点着色器需要输出一种“齐次坐标”，这种坐标把所有平行的向量视为相同的向量，即点$(x,y,z)$与点$(kx,ky,kz)$与点$(x/z,y/z,1)$都对应到画布上$(x/z,y/z)$这一个点，这样就能方便将相机背后的点剔除了。
##### 遮挡剔除
除了剔除相机后面的物体，还需剔除被前方物体遮挡的物体。在传统三维渲染中，遮挡剔除用的是z深度缓存技术，即在每次绘制图元时，除了执行片元着色器对像素上色，还会渲染一张仅包含z轴深度信息的灰度图，叫做“深度缓存(Depth Buffer)”。在绘制下一个图元的某个像素时，将比较它与深度缓存中的深度值，若深度缓存中的深度更近，说明这个像素还在之前绘制的像素之后，则直接放弃该点的上色。之前的齐次坐标里刚好还没进行透视除法，保留了$z$轴深度信息，是不是我们就可以直接拿来用于深度缓存了呢？不是的。电脑储存数字的精度是有限的，物体可以离相机很近也可以很远，近处的细节往往比远处更重要，需要更多精度，因此与其存储深度值$z$还不如存储其倒数$1/z$来得实惠。

现在既要遮挡剔除又要用齐次坐标做视锥体裁剪，人们规定顶点着色器输出的最终向量是一个四维齐次坐标，前两个坐标分量用于屏幕位置， 第三个坐标分量用于深度检测，第四个坐标用于透视除法。比如空间中的点$(x,y,z)$将变成$(x,y,1,z)$，做透视除法后变成$(x/z,y/z,1/z,1)$，不仅实现了相机背后剔除、正确的近大远小变换，还实现了非均匀精度的深度缓存。其实所有三角形内部需要插值的数据都要在透视除法之前完成，否则会导致像下面的贴图那样产生透视畸变。总结起来就是，你以为顶点着色器的输出只是屏幕上的二维点的坐标，实际上它却是一个四维的齐次坐标，这很有必要！

### 光线跟踪技术

光栅化方法的优点是快速且技术成熟，但由于这种绘制三角形的方式跟真实的光学成像过程并不相同，在实现复杂阴影、折反射等光学现象时将非常吃力（在视锥体裁剪与遮挡剔除这里你应该能体会到一些了）。于是另一种方法——光线跟踪诞生了。相机之所以能够拍摄到物体是因为镜头后面的感光器件接受到了光线。最直接（Naïve）的做法就是让场景中的光源均匀采样随机发射光子，模拟光线的反弹，若打到一个相机中的某个像素所在的“感光区域”则记录下该光子对颜色亮度的累加贡献。然而这个算法是非常低效的，因为相机的感光面积一般很小，很多光子最终都不会反射到镜头中，一个简单的场景可能都需要上亿个光子才能勉强得到一张能看的照片。

解决问题的方法很简单。由于光路可逆，我们可以从相机均匀采样随机发射光线跟物体反弹，只要打到光源就能倒着求出该光线所贡献的亮度，这就是最简单的路径追踪渲染方法，它能渲染出照片级质量的图像！当然它需要发射的光线也非常多，特别是光源体积很小时，击中光源的概率也非常小。其实不要求真实性的话，我们完全可以在打到第一个物体的表面时就停下来，直接根据该物体的颜色计算该像素的颜色。

具体怎样用GPU进行光线跟踪呢？我们可以将整个图片覆盖两个三角形，伪装成光栅化渲染交给GPU，在最后为每个像素上色的片元着色器代码中计算光线向量与物体求交、计算颜色等操作。但GPU仅仅只能快速一次批量执行相同的指令，光线与物体相交与否会让不同的像素需要执行的后续命令大不相同，将大大降低光线跟踪在GPU上的并行计算效率，所以光线跟踪比光栅化要慢很多。为了解决这个问题人们又专门设计了能快速处理与三角形批量求交的硬件光追（如Nvdia的RTX系列）。

## 三维体素图像渲染
比起三维，四维场景的渲染的最大区别就是图片本身变成了一个三维的阵列，除了维数以外没有什么本质的区别。我们同样可以采用光栅化与光线跟踪两种技术。

### 光线跟踪

四维光线跟踪几乎与三维一模一样。一般常用的光追片元着色器语言是支持四维向量vec4这个类型的。如果只考虑与平面、球面求交，我们只需要把正常光追代码里的vec3改成vec4，就能把场景直接升级成与超平面、超球求交！为了能在GPU上运行，我们还需要将三维阵列分层，交给GPU处理渲染得到每一层的普通二维图像，把它们累起来就得到了三维体素图像。有了体素数据如何显示三维体素图像也是一件不简单的事，我们放到后面再说。
值得一提的是，由于像RTX之类的光追加速显卡是专门为三维空间中三角形求交设计的，似乎它不能对四面体求交提供加速，由于我没有真正接触过光追管线，也不排除能将四维数据“伪装”成三维数据来处理的可能（主观认为可行性很小）。
最后唯一一个值得注意的点则是，如果要做路径追踪，会遇到超球面上的均匀随机采样，需要简单推导一下公式。下面两段伪代码将分别生成方向均匀分布的单位三维、四维向量。
```
function generateRandVec3(){
  let a = Math.random() * 2.0 * Math.Pi;
  let c = Math.random() * 2.0 - 1.0;
  let b = Math.sqrt(1.0 - c * c);
  return new Vec3(b * Math.cos(a), b * Math.sin(a), c);
}
function generateRandVec4(){
  let a = Math.random() * 2.0 * Math.Pi;
  let b = Math.random() * 2.0 * Math.Pi;
  let c = Math.random();
  let sc = Math.sqrt(c);
  let cc = Math.sqrt(1.0 - c);
  return new Vec4(sc * Math.cos(a), sc * Math.sin(a), cc * Math.cos(b), cc * Math.sin(b));
}
```
### 光栅化方法
GPU能处理的基本图元——点、线、三角形它们都是数学上的单纯形（Simplex），我们自然就想到四维场景需要光栅化四面体。但由于GPU没有针对体素化四面体进行优化的硬件，我测试了我自己写的四面体光栅化器效率并不太高。为了尽可能利用现成的硬件性能优势，除非你专门研发设计一款四面体光栅化专用芯片，一般都采用分层渲染的方式，即计算并渲染3D图像的截面，而不是一次渲染一个四面体。所以我们将重点介绍切片光栅化方法。

不考虑复杂的光学现象，单从求图形截面与求图形投影的这两步来说，它们是可交换顺序的，即4D场景被相机拍成的3D图像的二维截面跟4D场景的3D截面再拍成二维图像的几何数据是一样的。现在，如何计算四维物体的截面就成了四维计算机图形学中的头号问题。计算截面的方法五花八门，我将介绍我所知道的方法。
#### 四面体法
用平面去截四面体可能会得到三角形亦或四边形。我们可以通过将四面体四个顶点分别代入平面方程的一边，通过符号判断它们是否位于同侧，若4个点都在一侧则无交集，若两侧分别有1、3个点，则截到三角形，若两侧各有两个点，则截到四边形。
#### 胞腔复形法
胞腔复形(CW-Complex)是四面体法的高级版。试想我们要用四面体法绘制体素立方体，则先要四面体化立方体，得到最少5个四面体。如果我们要剖分像正十二面体这样复杂的图形，四面体会多达近三十个，但正十二面体的截面最多不超过十边形，这就说明比起全用四面体，直接处理多面体、多边形将会减少很多不必要的图元。胞腔复形是多面体的推广，它提供了不采用四面体来描述四维物体的方法。胞腔复形记录了点、线、面、胞四种数据，其中顶点数据为坐标向量数组，边数据则为它的两个端点在顶点数组中的索引值，面数据中的每个面则记录组成它的所有边在边数组中的索引值，胞数据则为围成它的面在面数组中的索引值，这样层层构造出的东西就叫胞腔复形，它是可以推广到高维的。这么复杂的东西如何求它的截面呢？只要这个图形是凸的，其实用以下很简单的算法就能完成这个任务：

1. 首先计算所有顶点是否分别在超平面的两侧；
2. 对于每条边，检查它的端点是否跨过平面，若是，计算交点坐标；
3. 对于每一个面，检查它的边在上一步中有没有产生交点，若有将这些交点构造出截面图形的边。（注：若不要求图形是凸的，则交点可能不止两个，这样会得到不止两个端点的“非法”的边，算法就没法继续了）
4. 对于每个胞，检查它的面在上一步中有没有产生交线，若有将这些交线构造出截面图形的面。

最后要想渲染这样构造出的新的截面胞腔复形，对于非三角面还是得三角化，但取截面后三角化比起一来就四面体化产生的图元数量要少得多。如何三角化呢？由于我们假设了图形是凸的，完全可以直接选定一个顶点跟所有非相邻顶点连线即可。注意胞腔复形的数据没有顺序，这个三角化算法也不需要我们按顶点连接顺序排序。

胞腔复形有一个缺点就是难以表示贴图坐标。不像每个四面体直接在四个顶点上储存贴图坐标，然后通过线性插值得到内部每一点的坐标，胞腔复形的数据结构只直接包含围成胞的面的信息，并没有显式包含的顶点信息，且若一个胞的四面体剖分（或它的截面的三角剖分）方式不同，中间点插值得到的贴图坐标也会不同，且胞腔复形不适合在GPU上并行计算，因此Tesserxel引擎不直接采用胞腔复形来表示要渲染的四维物体。


#### 硬件实现计算截面
##### CPU计算截面
这是最简单粗暴的方法了。就是每次渲染前，让CPU先提前计算好四维场景的截面，得到一个三维场景，然后直接用传统3D渲染的各种技术去渲染就好了。然而它的缺点是，场景复杂后CPU的负担会特别重。目前来看，胞腔复形法一般就只适合在CPU上运行，因为它必须有顺序地从点、线再到面地串起来执行，且同一能并行计算的层级中每个面、胞的边界数一般也不同，因此很难发挥并行效率。我写的Tesserexel的前身4dViewer（除Minecraft4d外）就采用的CPU计算胞腔复形截面来渲染的四维场景，在物体面数不多的情况下其实速度还可以，渲染超球这些都无压力。贴图坐标确实没有解决，因此4dViewer（除Minecraft4d外）中的四维物体表面都是纯色，没有贴图。
##### GPU计算截面
虽然相比于胞腔复形法四面体法的计算量更大，但它的并行度非常高，更适合在GPU上并行计算并绘制截面。我将介绍在GPU上的各种四面体截面算法。由于GPU的工作流程（渲染管线）都是为常见3D渲染设计的，并没有设计求截面的功能，我们需要通过各种技巧来实现这一功能。根据求截面使用的着色器的种类可分成下面三种方法。

1. 顶点着色器计算截面
这是Youtuber CodeParade使用的算法。每个四面体为四个顶点，求截面可能得到空集、三角形或四边形，则GPU最后可能要绘制0~2个三角形。为了让GPU画出2个三角形，我们可以把每个四面体的四个顶点数据与三角形编号打包起来复制四份，让GPU在顶点着色器里运行四次计算截面三角形的最终坐标。注意由于需要判断顶点编号以及顶点是否位于平面的同侧异侧来决定最终的截面，着色器里面将会充斥着许多影响并行计算效率的条件分支语句。CodeParade采用存储一张预计算的纹理贴图，通过查表的方法来规避它们。
2. 几何着色器计算截面
这篇论文采用的是另一种更先进的做法：大多数GPU渲染管线中，在顶点着色器至光栅化器之前其实还可以插入一个可选的几何着色器(Geometry Shader)。这个几何着色器可以接受顶点着色器的输入，并输出程序员可自行控制的任意数量的基本图元，感觉这个着色器就像是专门为计算截面设置的！由于几何着色器是在顶点着色器之后，它接受的是由顶点着色器变换后的图元的所有顶点，因此我们需要将四个顶点坐标组合成一种图元。而已知的基本图元里面只有点、线、三角形，它们顶点ü都没到4个。幸好，几何着色器的设计者早就料到了人们可能会有这些特殊需求，提供了只能作为几何着色器输入的一类特殊图元（Adjacency Primitives），如使用图元gl_lines_adjacency可以恰好将四个顶点打包扔给几何着色器计算。
3. 计算着色器计算截面
很遗憾，网页端的传统GPU编程接口WebGl与最新接口WebGPU都不支持几何着色器，但WebGPU提供了一种新的“计算着色器(Compute Shader)”。计算着色器是为了完成除图像绘制外的通用并行计算任务而生的，比如用于大数据机器学习之类的场景。我们可以将四面体顶点数据发送给计算着色器，计算截面后得到截面的顶点数据，再将这些数据传入至传统渲染管线中的顶点着色器，从而完成后续的渲染工作。Tesserxel默认就采用的是计算着色器来处理四维物体截面。计算着色器并行地处理每一个四面体，得到0至2个三角形。我采用了一个大的数组来存放这些三角形。由于无法知道不同并行计算单元的执行顺序（不知道谁快谁慢），在大家往大数组里写三角形时可能会存在“数据竞争(Data Race)”——即可能两个并行的四面体截面程序同时往数组的一个格子里写三角形数据，后写入的数据将覆盖掉先写入的。WebGPU提供了一种叫“原子”的操作来规避数据竞争：我们用一种“原子整数”类型的变量来存储数组下一个空闲位置的角标。第一个执行到需要读写这种原子类型的变量时，就将“锁定”它，直到它读完数据值并将变量更新为下一个空闲位置的角标（其实就是单纯角标值加一）后再“解锁”，而其它程序若执行到了需要读写被上锁的原子类型的变量，它们将在这里停下，等待变量被解锁后再执行。由于读变量，再将变量值递增一的运算时间特别短，所以其它程序不会为等待解锁而浪费太多时间，并行度还是很高的。

截面求出来后下一步就是做渲染。无论是以上哪种方法都会遇到之前的两个问题——视锥体裁剪与遮挡剔除。按三维空间的类比，渲染四维几何体需要一个五维的齐次向量，它前三个分量是体素画布上的位置，第四个是用于处理前后遮挡关系的深度缓存，最后一个则用于透视除法。目前世界上所有的GPU都是为3D渲染设计的，没有提供五阶矩阵与五维向量vec5，光栅化器的硬件层面也没有相应的处理逻辑。幸好我们只是一次绘制一个四维物体的截面，于是可以这样做：

1. 首先对四面体的顶点进行坐标变换得到五维齐次坐标，由于没有提供vec5这一数据类型，我们可以用一个浮点数变量和一个vec4变量来分别储存。
2. 在齐次坐标下计算截面数据(计算方法可以简单地从普通坐标系下推导过去得到)，求出交点的齐次坐标。
3. 假设截面垂直于体素图片的某个坐标轴。由于交点一定位于截面内，我们可以直接忽略掉现在已经无用的垂直于截面的坐标，将齐次向量维数降低成四维，作为最终顶点着色器的输出发送给GPU当成普通的三维图形处理视锥体裁剪与遮挡剔除。

好了，总算把四维物体的光栅化渲染方法说完了，下面来看看一些完全不一样的东西。

### 非体素渲染算法
可视化四维图形不一定非得要计算“真实”的光线颜色信息，我将介绍线框渲染法与球极投影算法这两种典型的非体素渲染算法。
## 线框渲染
由于我们人类天生就没有能同时看到三维内部所有体素的三维视网膜的眼睛，体素渲染将带来很多颜色的重叠。线框渲染可大大降低重叠的像素，让人的理解难度降低（当然这只是某方面的降低，有得必有失），所以在四维计算机图形学领域，线框渲染反而比那些带体素颜色的渲染运用得更多，比如4DBlock与yugu233均采用该方法可视化四维物体。单纯渲染线框没什么好说的：首先对顶点进行坐标变换至三维相机的感光超平面上，得到类似的体素图片中的坐标，然后再将三维坐标投影到二维后，再连接各端点画出线段。但这样的算法有两个大问题，对，还是那两个问题——视锥体裁剪与遮挡剔除。
### 视锥体裁剪
由于要绘制的线段完全可能一端在相机前，一端在相机后，直接做透视投影中的透视除法将导致结果混乱。又由于不再采用光栅化方法绘制，这就要求我们要手动计算要绘制的线段与视锥体的交点，只保留相交部分。其实不只是前后，现在连上下左右也必须手动裁剪。
### 更棘手的问题——遮挡剔除
由于现在是直接在最终的二维屏幕上绘制线条，不再分层渲染，我们也没法得到深度缓存来进行遮挡剔除。于是我们必须像光线跟踪那样来解析地计算线段和每个面的遮挡关系变化处的坐标。如何做到呢？将相机看作一盏灯，每个面（胞）后面的阴影区域即为它遮挡的区域，我们的任务就是算出线段与该区域的交集并剔除掉它们。这些区域都是由超平面围成的，求解交点并不复杂，难的是判断遮挡关系。Block4d的作者给了一种算法：

注意此时我们只剔除了一个胞对线段的遮挡，对于其余的胞，Block4d的作者采用的是递归的方法，即完整线段在剔除中间部分后被一分为二，将视为两条线段参与下一轮另外胞对它们的遮挡剔除。这里也可以采用不递归的方法，只存储一个覆盖区间的列表，最终再统一将线段分隔后进行渲染。

### 线框渲染的并行化

线框渲染的复杂剔除逻辑导致它能够在CPU上很好实现却难以移植到GPU中。

## 球极投影算法
光线跟踪、直接法
## 多面体算法
陪集枚举算法搞懂后更新（推荐pywonderland朝花夕拾）
### 胞腔复形的定向

### 锥形
锥形的表面由底面与底面边缘锥化而来的侧面组成，将胞腔$A$的锥化记作$\widehat{A}$，设$\dim{A}=n$，引入表示定向的未知数$a$，选择与底面相容的定向，则有：$$\partial(\widehat{A}) = A + a(n) \widehat{\partial A}$$两边再取边缘算子，得到$$0=\partial A + a(n) (\partial A + a(n-1) \widehat{\partial \partial A} )$$最终得到$a(n)=-1$。
#### 直积形
我们知道直积形的表面有公式$\partial (A \times B) = \partial A \times B + A \times \partial B$，但这个公式完全没涉及定向，需要改造公式：加入表示定向的未知数$a $与$b$，它们均只能取$\pm 1$，且跟图形维度有关，设$\dim{A}=m$，$\dim{B}=n$，则这里的$a$、$b$其实是$m,n$的函数，即：$$\partial (A \times B) = a(m,n)\partial A \times B + b(m,n)A \times \partial B$$由于定向一定有两种选择，所以可以人为选择一个方向作为两个定向图形的直积形的定向的定义，这里我选择$b(m,n)=1$，即在直积后保持A图形的定向与原A图形定向一致，于是有：$$\partial (A \times B) = a(m,n)\partial A \times B + A \times \partial B$$边界一定封闭，即$$\partial^2 (A \times B) = 0 = a(m,n)\partial(\partial A \times B) + \partial(A \times \partial B)$$利用$\partial^2A=0$与$\partial^2B=0$，再注意$\dim(\partial A)=m-1$，$\dim(\partial B)=n-1$，可以化简得到：$$0 = a(m,n)(\partial A \times \partial B) + a(m,n-1)(\partial A \times \partial B)$$$A$与$B$可以是任意图形，因此要让等式恒成立就有$a(m,n)=-a(m,n-1)$，为了能让递推式能顺利进行，我们需要给出初值。当图形$B$为0维点时，我们希望它能像标量一样直接不改变图形A的定向，即$a(m,0) = 1$，这样我们就得到了$a(m,n)=(-1)^n$。

## 四维转动惯量的主轴求解

首先计算质点的惯量矩阵。设单个质点的坐标为$r=(r_x,r_y,r_z,r_w)$。它惯量矩阵为：
$$\begin{pmatrix}r_x^2+r_y^2&r_yr_z&r_yr_w&-r_xr_z&-r_xr_w&0\\\\r_yr_z&r_x^2+r_z^2&r_zr_w&r_xr_y&0&-r_xr_w\\\\r_yr_w&r_zr_w&r_x^2+r_w^2&0&r_xr_y&r_xr_z\\\\-r_xr_z&r_xr_y&0&r_y^2+r_z^2&r_zr_w&-r_yr_w\\\\-r_xr_w&0&r_xr_y&r_zr_w&r_y^2+r_w^2&r_yr_z\\\\0&-r_xr_w&r_xr_z&-r_yr_w&r_yr_z&r_z^2+r_w^2\end{pmatrix}$$
对于一般的刚体来说则是很多个这样的质点的惯量矩阵的叠加，但无论怎样叠加，矩阵的某些性质是不变的，如副对角线元素始终为0，转换到等角坐标我们将看到该矩阵的更多性质：
$$\begin{pmatrix}
\frac{1}{2}(r_x^2+r_y^2+r_z^2+r_w^2)&0&0&\frac{1}{2}(r_x^2+r_y^2-r_z^2-r_w^2)&r_yr_z-r_xr_w&r_xr_z+r_yr_w\\\\0&\frac{1}{2}(r_x^2+r_y^2+r_z^2+r_w^2)&0&r_xr_w+r_yr_z&\frac{1}{2}(r_x^2-r_y^2+r_z^2-r_w^2)&r_zr_w-r_xr_y\\\\0&0&\frac{1}{2}(r_x^2+r_y^2+r_z^2+r_w^2)&r_yr_w-r_xr_z&r_xr_y+r_zr_w&\frac{1}{2}(r_x^2-r_y^2-r_z^2+r_w^2)\\\\\frac{1}{2}(r_x^2+r_y^2-r_z^2-r_w^2)&r_xr_w+r_yr_z&r_yr_w-r_xr_z&\frac{1}{2}(r_x^2+r_y^2+r_z^2+r_w^2)&0&0\\\\r_yr_z-r_xr_w&\frac{1}{2}(r_x^2-r_y^2+r_z^2-r_w^2)&r_xr_y+r_zr_w&0&\frac{1}{2}(r_x^2+r_y^2+r_z^2+r_w^2)&0\\\\r_xr_z+r_yr_w&r_zr_w-r_xr_y&\frac{1}{2}(r_x^2-r_y^2-r_z^2+r_w^2)&0&0&\frac{1}{2}(r_x^2+r_y^2+r_z^2+r_w^2)\end{pmatrix}
$$
这个矩阵有点庞大，注意很多质点叠加后矩阵中每个元素的项数将会非常多，我们只能关注它的总体形状。下面我们就将把所有质点加在一起，将其写成分块矩阵的形式，其中$\lambda=\frac{1}{2}\sum_i(r_{i,x}^2+r_{i,y}^2+r_{i,z}^2+r_{i,w}^2)$，而$\text{P}$通常为一个非对称的三阶矩阵。
$$\begin{pmatrix}
\lambda \text{I}\_{3\times 3} & \text{P} \\\\ \text{P}^T & \lambda \text{I}\_{3\times 3}
\end{pmatrix}$$

根据主轴的定义，主轴坐标系下转动惯量矩阵为对角阵，但将其转换至等角坐标下却不再是对角阵，而是上面的子阵$P$也是对角阵的分块矩阵，这启发我们只要找到合适的旋转能将$\text{P}$对角化即可找到旋转至主轴坐标系的变换。

由于左右等角旋转的对易性，任意的四维2-向量旋转矩阵转化到等角坐标系下将会变成含两个三阶正交阵（$\text{A}$、$\text{B}$）的分块矩阵：
$$\text{R}=\begin{pmatrix}
\text{A} & 0 \\\\ 0 & \text{B}
\end{pmatrix}$$
我们正是要靠这个旋转矩阵来对角化矩阵$\text{P}$：
$$\begin{pmatrix}
\text{A} & 0 \\\\ 0 & \text{B}
\end{pmatrix} \begin{pmatrix}
\lambda \text{I}\_{3\times 3} & \text{P} \\\\ \text{P}^T & \lambda \text{I}\_{3\times 3}
\end{pmatrix} \begin{pmatrix}
\text{A}^T & 0 \\\\ 0 & \text{B}^T
\end{pmatrix} =\begin{pmatrix}
\lambda \text{I}\_{3\times 3} & \Lambda \\\\ \Lambda & \lambda \text{I}\_{3\times 3}
\end{pmatrix}$$
计算左边矩阵乘法，对比等式两边可得出$\Lambda=\text{AP} \text{B}^T$。由于$\text{A}$、$\text{B}$都是正交阵，我们可以通过奇异值分解这个经典算法来求解$\text{A}$、$\text{B}$，求解完后则得到了等角坐标系下的完整的四维2-向量旋转矩阵$\text{R}$。

注意矩阵$\text{R}$是六阶的，所以还需要求出原来的四维旋转矩阵或旋转的旋量/四元数表示。最优雅的方式是直接在等角坐标系下完成这个转换工作：正交阵$\text{A}$、$\text{B}$代表的其实就是该旋转的左右手等角旋转部分，把这些三阶正交矩阵表示的旋转直接转换成四元数表示的旋转就能得到整个旋转的四元数表示。

## 如何旋转一个2-向量

旋转矩阵不能直接作用于表示平面的“2-向量”，它们是两个体系，必须转换到同一种体系中才能运算。

第一种方法统一采用张量的语言。将2向量看作0,2型张量Pij，由于有两个指标，需要乘两次坐标变换的矩阵，写成矩阵是RPR'('代表转置)，这跟线性变换的坐标变换是类似的，只左乘一个旋转矩阵是错误的，可以验证右边再乘上转置后就是反对称的了。

第二种方法是把2-向量用矩阵向量的语言重新表述：设旋转矩阵为R，把2-向量看作是六维向量(xy/xz/xw/yz/yw/zw)，我们可以构建一个六维正交矩阵对六维向量进行旋转，这个矩阵的每一列代表着xy/yz这样的基2-向量旋转后的结果，即R(x)^R(y)，同理计算其它五个分量就可以填满整个6阶矩阵。

第三种方法是全部采用几何代数的语言：将旋转矩阵转换成旋量R（偶数阶k-向量），对表示平面的“2-向量”P的旋转为RPR~(这里的~代表几何代数里的共轭)，这个跟方法一的表达式很像，但其实原理与计算过程完全不一样。

第四种方法是我找到的一个只针对四维空间旋转的方法（利用了旋量群的一个性质Spin(4)=SO(3)xSO(3)，是我最喜欢的方法）：四维旋转R能分成左右两个等角旋转Rl、Rr，每一部分可以用一个四元数表示。把表示平面的2-向量分解P为自对偶与反自对偶两部分(P=A+B)，可以证明反自对偶2-向量有着左等角旋转对称性（即作用后不变），自对偶2-向量有着右等角旋转对称性，这样就只需分别处理左等角旋转作用自对偶与右等角旋转作用反自对偶两部分。每部分都跟用四元数做三维旋转一样（自对偶/反自对偶的2-向量都恰有3个分量），这样最终的2-向量为Rl A Rl' + Rr B Rr'，我写的四维图形引擎里就用的是这个公式。

## 参考文献